
I plan on elaborating the message scheme in this document. In the future this
should be cleaned up and turned into a presentable file.

Three parts of the backend simulation message architecture are relevant for
frontend communication. Each of these will follow a JSON messaging scheme
  1) Hook messages into and from architecture
  2) Control messages (Run, Reset, Step)
  3) Configure messages (New architecture, new virtual IO)
  
Note that this is not yet implemented however the goal is for the backend to implement
behavior so as to use these features of the architecture constructed.

Note See hook_documentation.txt to get further details on how hooks are to interact
with this concept interface

General Message Scheme

{
  "<type>"" : < payload >
}

Hook Message Scheme

{
  "hook" : {
    "hook method*" : <message to hook>
}


[*] if applicable

  Examples!

  @inspect
  {
    "hook" : {
      "inspect" : ["h1","h2"...]
    }
  }

  @modify
  {
    "hook" : {
      "modify" : {
        "name" : "h1",
        "parameters" : {
          "state" : <some number>
        }
      }
    }
  }

  @generate
  {
    "hook" : {
      "generate" : {
        "name" : "<hook name>",
        "parameters" : {
          "state" : <some number>
        }
      }
    }
  }


Control Message Scheme

{
  "architecture" : <message to architecture>
}

  Examples!

  @limits
  {
    "architecture" : {
      "limits" : null
    }
  }

  @configuration
  {
    "architecture" : {
      "configuration" : {
      }
    }
  }

  @simulate
  {
    "architecture" : {
      "simulate" : {
        "type" : "logic or time"
        "steps" : <number of time steps to take> or
        "run" : null
        "return" : true / false
      }
    }
  }
